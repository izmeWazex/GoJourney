# GoJourney
GoLang 90-Day Zero-to-Hero Problem Set

Each day = 1 problem. Difficulty gradually increases.


Phase 1: Go Basics (Days 1–15)
1. **Print Hello Go** – Print "Hello, Go!" using `fmt.Println`.
2. **Variables Swap** – Swap two integers without using a temporary variable.
3. **Even or Odd** – Check if a number is even or odd.
4. **FizzBuzz** – Classic FizzBuzz for numbers 1–100.
5. **Factorial** – Compute factorial using recursion.
6. **Sum of Digits** – Find the sum of digits of a given number.
7. **Palindrome String** – Check if a string is palindrome.
8. **Prime Check** – Determine if a number is prime.
9. **Reverse Array** – Reverse an integer slice.
10. **Find Max** – Find the maximum element in a slice.
11. **Unique Characters** – Check if a string has all unique characters.
12. **Count Vowels** – Count vowels in a string.
13. **Armstrong Number** – Check if a number is Armstrong.
14. **Anagram Check** – Determine if two strings are anagrams.
15. **Remove Duplicates** – Remove duplicates from a slice.

Phase 2: Data Structures (Days 16–30)
16. **Stack Implementation** – Implement stack using slice.
17. **Queue Implementation** – Implement queue using slice.
18. **Linked List Basics** – Create a singly linked list.
19. **Reverse Linked List** – Reverse a linked list.
20. **Detect Cycle** – Detect a cycle in linked list.
21. **Binary Search** – Implement binary search on sorted slice.
22. **Merge Sorted Arrays** – Merge two sorted arrays.
23. **Matrix Transpose** – Find transpose of a matrix.
24. **Spiral Matrix** – Print matrix in spiral order.
25. **Rotate Array** – Rotate array by k steps.
26. **Two Sum** – Classic 2-sum problem.
27. **Valid Parentheses** – Check if parentheses string is valid.
28. **Min Stack** – Implement a stack with getMin() in O(1).
29. **Implement HashMap** – Create your own simple hashmap.
30. **LRU Cache** – Implement Least Recently Used cache.


Phase 3: Algorithms (Days 31–60)
31. **Bubble Sort**
32. **Insertion Sort**
33. **Selection Sort**
34. **Merge Sort**
35. **Quick Sort**
36. **Heap Sort**
37. **Counting Sort**
38. **Binary Search Tree Insert**
39. **BST Inorder Traversal**
40. **BST Search**
41. **Graph BFS**
42. **Graph DFS**
43. **Topological Sort**
44. **Dijkstra’s Algorithm**
45. **Bellman-Ford Algorithm**
46. **Floyd-Warshall**
47. **Kruskal’s Algorithm (MST)**
48. **Prim’s Algorithm (MST)**
49. **Union-Find (Disjoint Set)**
50. **N-Queens Problem**
51. **Sudoku Solver**
52. **Word Search**
53. **Longest Common Subsequence**
54. **Edit Distance**
55. **Longest Increasing Subsequence**
56. **Maximum Subarray (Kadane’s)**
57. **Coin Change Problem**
58. **Climbing Stairs**
59. **House Robber**
60. **Jump Game**


Phase 4: Concurrency + Advanced Go (Days 61–90)
61. **Goroutine Basics** – Launch a goroutine to print "Hello from goroutine".
62. **Channel Basics** – Send and receive data via channel.
63. **Buffered Channels** – Demonstrate buffered channel.
64. **Worker Pool** – Implement worker pool with goroutines.
65. **Producer-Consumer** – Implement producer-consumer with channels.
66. **Mutex Example** – Use `sync.Mutex` to avoid race condition.
67. **WaitGroup Example** – Use `sync.WaitGroup` for goroutines sync.
68. **Select Statement** – Demonstrate select with multiple channels.
69. **Context with Cancel** – Stop goroutine with context.
70. **Rate Limiter** – Implement rate limiter with time.Ticker.
71. **Concurrent Map Access** – Use `sync.Map`.
72. **Concurrent Web Scraper** – Fetch multiple URLs concurrently.
73. **Pipeline Pattern** – Implement goroutine pipeline.
74. **Fan-In / Fan-Out Pattern** – Parallelize work.
75. **Timeouts with Context** – Handle timeout in goroutines.
76. **Deadlock Example** – Show a deadlock and fix it.
77. **Dining Philosophers Problem** – Implement with goroutines.
78. **Philosopher’s Deadlock-Free Solution** – Optimize.
79. **Parallel Matrix Multiplication**.
80. **Concurrent File Downloader**.
81. **Concurrent Word Count**.
82. **Concurrent Prime Generator**.
83. **Build a Mini CLI App**.
84. **Build a REST API with net/http**.
85. **Add Middleware to API**.
86. **CRUD with Maps + JSON API**.
87. **JWT Authentication in Go**.
88. **Go + MySQL Connection**.
89. **Go + Redis Connection**.
90. **Build a Full Concurrency-Safe Todo App**.

Do you want me to **format these into actual LeetCode-style problem statements** (with input/output examples + constraints), or keep it as a clean roadmap checklist?
